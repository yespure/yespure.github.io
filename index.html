<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galerie D'Art - Infinite</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Lato:wght@300;400&family=Playfair+Display:ital,wght@0,400;0,600;1,400&display=swap');

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #f7f7f5;
            font-family: 'Lato', sans-serif;
            color: #111;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }

        .logo {
            position: fixed;
            top: 40px;
            left: 50px;
            font-family: 'Playfair Display', serif;
            font-weight: 700;
            letter-spacing: 2px;
            font-size: 1rem;
            text-transform: uppercase;
            z-index: 10;
        }

        .slide-content {
            position: absolute;
            top: 25%;
            left: 8%;
            width: 30%;
            max-width: 450px;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.8s ease, transform 0.8s ease-out;
            pointer-events: auto; 
        }

        .slide-content.active {
            opacity: 1;
            transform: translateY(0);
        }

        h1 {
            font-family: 'Playfair Display', serif;
            font-weight: 400;
            font-style: italic;
            font-size: 4rem;
            margin: 0 0 1.5rem 0;
            line-height: 1;
            color: #0d0d0d;
        }

        .catalogue-number {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 3px;
            color: #999;
            margin-bottom: 1.5rem;
            display: inline-block;
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
        }

        .description {
            font-size: 1.05rem;
            font-weight: 300;
            line-height: 1.8;
            color: #444;
            margin-bottom: 3rem;
            text-align: justify;
        }

        .meta-grid {
            display: grid;
            grid-template-columns: 80px 1fr;
            row-gap: 0.8rem;
            border-top: 1px solid #e0e0e0;
            padding-top: 1.5rem;
        }

        .meta-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: #888;
            align-self: center;
        }

        .meta-value {
            font-family: 'Playfair Display', serif;
            font-size: 1.1rem;
            font-style: italic;
            color: #222;
        }
        
        .scroll-hint {
            position: fixed;
            bottom: 40px;
            left: 50px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: #aaa;
        }
        #bg-image-layer {
        position: fixed;
        inset: 0;
        z-index: 0;
        pointer-events: none;

        background-repeat: no-repeat;
        background-position: center;
        background-size: 70% auto;

        opacity: 0;
        transition: opacity 1s ease;

        mask-image: radial-gradient(
            circle at center,
            rgba(0,0,0,1) 45%,
            rgba(0,0,0,0.6) 60%,
            rgba(0,0,0,0) 75%
        );
        -webkit-mask-image: radial-gradient(
            circle at center,
            rgba(0,0,0,1) 45%,
            rgba(0,0,0,0.6) 60%,
            rgba(0,0,0,0) 75%
        );
    }

    #bg-dots-layer {
        position: fixed;
        inset: 0;
        z-index: 1;
        pointer-events: none;

        background-image: radial-gradient(#000 0.8px, transparent 0.8px);
        background-size: 10px 10px;
        opacity: 0.3;
    }

    </style>
</head>
<body>

    <div class="logo">GALLERIE D'ART</div>
    
    <div id="bg-image-layer"></div>
    
    <div id="bg-dots-layer"></div>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        
        <div class="slide-content" id="slide-0">
            <span class="catalogue-number">01 / Collection</span>
            <h1>Ethereal <br>Form</h1>
            <div class="description">
                Captured in the gentle light of early morning, this piece explores the boundaries between reality and abstraction. The soft textures invite the viewer to look closer, revealing layers of complexity hidden within the simplicity.
            </div>
            <div class="meta-grid">
                <span class="meta-label">Artist</span> <span class="meta-value">Elena Varas</span>
                <span class="meta-label">Year</span> <span class="meta-value">2023</span>
                <span class="meta-label">Medium</span> <span class="meta-value">Oil on Linen</span>
            </div>
        </div>

        <div class="slide-content" id="slide-1">
            <span class="catalogue-number">02 / Collection</span>
            <h1>Geometric <br>Silence</h1>
            <div class="description">
                A study in precision and balance. By stripping away organic chaos, the artist reveals the quiet mathematical purity that underlies nature. The composition demands a moment of stillness from its observer.
            </div>
            <div class="meta-grid">
                <span class="meta-label">Artist</span> <span class="meta-value">Marcus Thorne</span>
                <span class="meta-label">Year</span> <span class="meta-value">2024</span>
                <span class="meta-label">Medium</span> <span class="meta-value">Acrylic & Graphite</span>
            </div>
        </div>

        <div class="slide-content" id="slide-2">
            <span class="catalogue-number">03 / Collection</span>
            <h1>Fading <br>Horizons</h1>
            <div class="description">
                The horizon line serves as a metaphor for the futureâ€”always visible yet forever out of reach. The bleeding colors suggest the fluidity of memory and the inevitable passage of time.
            </div>
            <div class="meta-grid">
                <span class="meta-label">Artist</span> <span class="meta-value">Isabella Rossi</span>
                <span class="meta-label">Year</span> <span class="meta-value">2022</span>
                <span class="meta-label">Medium</span> <span class="meta-value">Watercolor Wash</span>
            </div>
        </div>

        <div class="slide-content" id="slide-3">
            <span class="catalogue-number">04 / Collection</span>
            <h1>The <br>Void</h1>
            <div class="description">
                A minimalist approach challenging the viewer to find meaning in emptiness. The texture of the canvas itself becomes the primary subject, inviting a purely tactile visual experience without distraction.
            </div>
            <div class="meta-grid">
                <span class="meta-label">Artist</span> <span class="meta-value">Unknown</span>
                <span class="meta-label">Year</span> <span class="meta-value">Late 20th C.</span>
                <span class="meta-label">Medium</span> <span class="meta-value">Mixed Media</span>
            </div>
        </div>

    </div>
    
    <div class="scroll-hint">Scroll to explore</div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const CONFIG = {
            slideCount: 4,
            spacingX: 45,
            
            pWidth: 14,
            pHeight: 18,
            
            camZ: 30,
            wallAngleY: -0.25,

            snapDelay: 200,
            lerpSpeed: 0.06
        };

        const totalGalleryWidth = CONFIG.slideCount * CONFIG.spacingX;

        const scene = new THREE.Scene();
        scene.background = null;
        scene.fog = new THREE.Fog(0xf7f7f5, 10, 110); 

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, CONFIG.camZ);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(10, 20, 10);
        scene.add(dirLight);

        const galleryGroup = new THREE.Group();
        scene.add(galleryGroup);

        const textureLoader = new THREE.TextureLoader();
        const planeGeo = new THREE.PlaneGeometry(CONFIG.pWidth, CONFIG.pHeight);

        const images = [
            'https://images.unsplash.com/photo-1549880338-65ddcdfd017b?w=800&q=80',
            'https://images.unsplash.com/photo-1582201942988-13e60e4556ee?w=800&q=80',
            'https://images.unsplash.com/photo-1513364776144-60967b0f800f?w=800&q=80',
            'https://images.unsplash.com/photo-1577720580479-7d839d829c73?w=800&q=80'
        ];
        const bgLayer = document.getElementById('bg-image-layer');
        let currentBgIndex = -1;

        const paintingGroups = [];

        for(let i=0; i<CONFIG.slideCount; i++) {
            const group = new THREE.Group();
            group.position.set(i * CONFIG.spacingX, 0, 0);
            const mat = new THREE.MeshBasicMaterial({ map: textureLoader.load(images[i]) });
            const mesh = new THREE.Mesh(planeGeo, mat);
            const edges = new THREE.EdgesGeometry(planeGeo);
            const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x222222 }));

            const shadowGeo = new THREE.PlaneGeometry(CONFIG.pWidth, CONFIG.pHeight);
            const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.15 });
            const shadow = new THREE.Mesh(shadowGeo, shadowMat);
            shadow.position.set(0.8, -0.8, -0.5); 

            const lineZ = -1;
            const lineLen = CONFIG.spacingX;
            const lineGeo = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-lineLen/2, 14, lineZ), new THREE.Vector3(lineLen/2, 14, lineZ),
                new THREE.Vector3(-lineLen/2, -14, lineZ), new THREE.Vector3(lineLen/2, -14, lineZ)
            ]);
            const lines = new THREE.LineSegments(lineGeo, new THREE.LineBasicMaterial({ color: 0xdddddd }));

            group.add(shadow);
            group.add(mesh);
            group.add(outline);
            group.add(lines);
            
            galleryGroup.add(group);
            paintingGroups.push(group);
        }

        galleryGroup.rotation.y = CONFIG.wallAngleY;
        galleryGroup.position.x = 8; 

        let currentScroll = 0;
        let targetScroll = 0;
        let snapTimer = null;
        let mouse = { x: 0, y: 0 };

        function snapToNearest() {
            const index = Math.round(targetScroll / CONFIG.spacingX);
            targetScroll = index * CONFIG.spacingX;
        }

        window.addEventListener('wheel', (e) => {
            targetScroll += e.deltaY * 0.1;            
            if(snapTimer) clearTimeout(snapTimer);
            snapTimer = setTimeout(snapToNearest, CONFIG.snapDelay);
        });

        let touchStart = 0;
        window.addEventListener('touchstart', e => {
            touchStart = e.touches[0].clientX;
            if(snapTimer) clearTimeout(snapTimer);
        });
        
        window.addEventListener('touchmove', e => {
            const diff = touchStart - e.touches[0].clientX;
            targetScroll += diff * 0.6;
            touchStart = e.touches[0].clientX;
            if(snapTimer) clearTimeout(snapTimer);
        });

        window.addEventListener('touchend', () => {
            snapToNearest();
        });

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

       function updateUI(scrollX) {
    const rawIndex = Math.round(scrollX / CONFIG.spacingX);            
    const safeIndex = ((rawIndex % CONFIG.slideCount) + CONFIG.slideCount) % CONFIG.slideCount;     

    for (let i = 0; i < CONFIG.slideCount; i++) {
        const el = document.getElementById(`slide-${i}`);
        if (el) {
            if (i === safeIndex) el.classList.add('active');
            else el.classList.remove('active');
        }
    }

    if (safeIndex !== currentBgIndex) {
        currentBgIndex = safeIndex;
        bgLayer.style.opacity = 0;

        setTimeout(() => {
            bgLayer.style.backgroundImage = `url(${images[safeIndex]})`;
            bgLayer.style.opacity = 0.6;
        }, 300);
    }
}

        function animate() {
            requestAnimationFrame(animate);
            currentScroll += (targetScroll - currentScroll) * CONFIG.lerpSpeed;
            const xMove = currentScroll * Math.cos(CONFIG.wallAngleY);
            const zMove = currentScroll * Math.sin(CONFIG.wallAngleY);
            camera.position.x = xMove;
            camera.position.z = CONFIG.camZ - zMove;
            paintingGroups.forEach((group, i) => {
                const originalX = i * CONFIG.spacingX;
                const distFromCam = currentScroll - originalX;
                const shift = Math.round(distFromCam / totalGalleryWidth) * totalGalleryWidth;
                group.position.x = originalX + shift;
            });
            camera.rotation.x = mouse.y * 0.05; 
            camera.rotation.y = -mouse.x * 0.05;
            updateUI(currentScroll);
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
        
    </script>
</body>
</html>
